#include<bits/stdc++.h>#define lson rt<<1#define rson rt<<1|1#define fi first#define se second#define lowbit(x) (x&(-(x)))#define mme(a,b) memset((a),(b),sizeof((a))) #define fuck(x) cout<<"* "<<x<<"\n"#define iis std::ios::sync_with_stdio(false)using namespace std;typedef long long LL;typedef unsigned long long uLL;const int N = 1e6 + 7;const int ME = 1e6 + 7;const int mod = 1000000007;const int INF = 0x3f3f3f3f;std::vector<int> son[N];int dis[N],dis2[N];int n, m, tot, flag;int ar[N];void dfs(int u,int Fa,int t){  dis[u]=t;  int len = son[u].size();  for(int i=0;i<len;++i){    int v = son[u][i];    if(v==Fa)continue;    dfs(v, u,t+1);  }}void find(int u,int Fa,int t){  dis2[u]=t;  int len = son[u].size();  for(int i=0;i<len;++i){    int v = son[u][i];    if(v==Fa)continue;    find(v, u,t+1);  }}int main(int argc, char const *argv[]){  while(~scanf("%d%d",&n,&m)){    for(int i=0;i<=n;++i)son[i].clear();    for(int i=1;i<n;++i){      int u,v;      scanf("%d%d",&u,&v);      son[u].push_back(v);      son[v].push_back(u);    }    if(m==1){      printf("0\n");      continue;    }    dfs(1,-1,0);    find(m,-1,0);    int mmax=0;    for(int i=1;i<=n;++i){      if(dis[i]>dis2[i]){        mmax=max(mmax,dis[i]);      }    }    printf("%d\n", mmax*2);  }  return 0;}/*#include <cstdio>#include <cstring>#include <iostream>#include <queue>#define mme(a,b) memset((a),(b),sizeof((a)))  #define test printf("***\n")#define fuck(x) cout<<"* "<<x<<"\n"#define iis std::ios::sync_with_stdio(false)using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int MXN = 1e4+7;const int MXE = 1e7+7;struct DINIC{  int tot,vt,vs;  int d[MXN],head[MXN];  struct lp{    int v,w,nex;  }cw[MXE];  void add_edge(int a,int b,int c){    cw[++tot].v=b;cw[tot].nex=head[a],cw[tot].w=c;    head[a]=tot;    cw[++tot].v=a;cw[tot].nex=head[b],cw[tot].w=0;    head[b]=tot;  }  bool bfs(){    memset(d,-1,sizeof(d));    queue<int>Q;    Q.push(vt);d[vt]=0;    while(!Q.empty()){      int u=Q.front();      Q.pop();      for(int i=head[u];i!=-1;i=cw[i].nex){        int v=cw[i].v;        if(cw[i^1].w&&d[v]==-1){          d[v]=d[u]+1;          Q.push(v);        }      }    }    return d[vs]!=-1;  }  int dfs(int x,int f){    if(x==vt||f==0) return f;    int use=0,w;    for(int i=head[x];i!=-1;i=cw[i].nex){      int to=cw[i].v;      if(d[to]==d[x]-1 && cw[i].w){        w=dfs(to,min(cw[i].w,f-use));        cw[i].w-=w,cw[i^1].w+=w;        use+=w;        if(use==f) return f;      }    }    return use;  }  void init(int st,int ed){    tot=-1;    memset(head,-1,sizeof(head));    vs=st;vt=ed;  }  int max_flow(){    int ans=0;    while(bfs())ans+=dfs(vs,INF);    return ans;  }}dinic;const int N = 805;int n, m, p;int vs, vt;struct lp{  int m,a[N],b[N];}cw[N];int main(){#ifndef ONLINE_JUDGE    freopen("E://ADpan//in.in", "r", stdin);    //freopen("E://ADpan//out.out", "w", stdout);  #endif  while(~scanf("%d%d",&p,&n)){    vs=0;vt=2*n+1;    dinic.init(vs,vt);      }  return 0;}*//*#include <iostream>#include <cstdio>#include <cmath>#include <cstring>#include <ctime>#include <cstdlib>#include <string>#include <bitset>#include <vector>#include <set>#include <map>#include <queue>#include <algorithm>#include <sstream>#include <stack>#include <iomanip>using namespace std;typedef long long LL;const int MAXN = 605;const int MAXE = 4e5 + 7;const int INF = 0x3f3f3f3f;struct MCMF {    int S, T;//Ô´µã£¬»ãµã    int tot, n;    int st, en, maxflow, mincost;    bool vis[MAXN];    int head[MAXN], cur[MAXN], dis[MAXN];    int roade[MAXN], roadv[MAXN], rsz; //ÓÃÓÚ´òÓ¡Â·¾¶    queue <int> Q;    struct Edge {        int v, cap, cost, nxt, flow;        Edge() {}        Edge(int a, int b, int c, int d) {            v = a, cap = b, cost = c, nxt = d, flow = 0;        }    } E[MAXE], SE[MAXE];    void init(int _n) {        n = _n, tot = 0;        for(int i = 0; i <= n; i++) head[i] = -1;    }    void add_edge(int u, int v, int cap, int cost) {        E[tot] = Edge(v, cap, cost, head[u]);        head[u] = tot++;        E[tot] = Edge(u, 0, -cost, head[v]);        head[v] = tot++;    }    bool adjust() {        int v, min = INF;        for(int i = 0; i <= n; i++) {            if(!vis[i]) continue;            for(int j = head[i]; ~j; j = E[j].nxt) {                v = E[j].v;                if(E[j].cap - E[j].flow) {                    if(!vis[v] && dis[v] - dis[i] + E[j].cost < min) {                        min = dis[v] - dis[i] + E[j].cost;                    }                }            }        }        if(min == INF) return false;        for(int i = 0; i <= n; i++) {            if(vis[i]) {                cur[i] = head[i];                vis[i] = false;                dis[i] += min;            }        }        return true;    }    int augment(int i, int flow) {        if(i == en) {            mincost += dis[st] * flow;            maxflow += flow;            return flow;        }        vis[i] = true;        for(int j = cur[i]; j != -1; j = E[j].nxt) {            int v = E[j].v;            if(E[j].cap == E[j].flow) continue;            if(vis[v] || dis[v] + E[j].cost != dis[i]) continue;            int delta = augment(v, std::min(flow, E[j].cap - E[j].flow));            if(delta) {                E[j].flow += delta;                E[j ^ 1].flow -= delta;                cur[i] = j;                return delta;            }        }        return 0;    }    void spfa() {        int u, v;        for(int i = 0; i <= n; i++) {            vis[i] = false;            dis[i] = INF;        }        Q.push(st);        dis[st] = 0;        vis[st] = true;        while(!Q.empty()) {            u = Q.front(), Q.pop();            vis[u] = false;            for(int i = head[u]; ~i; i = E[i].nxt) {                v = E[i].v;                if(E[i].cap == E[i].flow || dis[v] <= dis[u] + E[i].cost) continue;                dis[v] = dis[u] + E[i].cost;                if(!vis[v]) {                    vis[v] = true;                    Q.push(v);                }            }        }        for(int i = 0; i <= n; i++) {            dis[i] = dis[en] - dis[i];        }    }    int zkw_flow(int s, int t) {        st = s, en = t;        spfa();        mincost = maxflow = 0;        for(int i = 0; i <= n; i++) {            vis[i] = false;            cur[i] = head[i];        }        do {            while(augment(st, INF)) {                memset(vis, false, n * sizeof(bool));            }        } while(adjust());        return mincost;    }}zkw;//u v Á÷Á¿ ·ÑÓÃconst int N = 55;inline int ab(int x){return x<0?-x:x;}int vs,vt;int n,m,p;int main() {#ifndef ONLINE_JUDGE    freopen("E://ADpan//in.in", "r", stdin);    //freopen("E://ADpan//out.out", "w", stdout);  #endif  while(~scanf("%d%d%d",&n,&m,&p)){    vs=n+m+1;vt=n+m+2;      }  return 0;}*//*#include<iostream>#include<cstdio>#include<cstring>#include<algorithm>#include<map>#include<queue>#include<set>#include<string>#include<cmath>#include<bitset>using namespace std;typedef long long LL;const int N=550;const int INF = 0x7fffffff;int n,m;int match[N];int lx[N],ly[N];int sx[N],sy[N];int weight[N][N];int dfs(int x) {    sx[x]=true;    for(int i=0; i<n; i++) {        if(!sy[i]&&lx[x]+ly[i]==weight[x][i]) {            sy[i]=true;            if(match[i]==-1||dfs(match[i])) {                match[i]=x;                return true;            }        }    }    return false;}int fax(int x) {    if(!x) {        for(int i=0; i<n; i++) {            for(int j=0; j<n; j++) {                weight[i][j]=-weight[i][j];            }        }    }    memset(match,-1,sizeof(match));    for(int i=0; i<n; i++) {        ly[i]=0;        lx[i]=-INF;        for(int j=0; j<n; j++) {            if(weight[i][j]>lx[i]) {                lx[i]=weight[i][j];            }        }    }    for(int i=0; i<n; i++) {        while(1) {            memset(sx,0,sizeof(sx));            memset(sy,0,sizeof(sy));            if(dfs(i))break;            int mic=INF;            for(int j=0; j<n; j++) {                if(sx[j]) {                    for(int k=0; k<n; k++) {                        if(!sy[k]&&lx[j]+ly[k]-weight[j][k]<mic) {                            mic=lx[j]+ly[k]-weight[j][k];                        }                    }                }            }            if(mic==0) return -1;            for(int j=0; j<n; j++) {                if(sx[j]) lx[j]-=mic;                if(sy[j]) ly[j]+=mic;            }        }    }    int sum=0;    for(int i=0; i<n; i++) {        if(match[i]>=0) {            sum+=weight[match[i]][i];        }    }    if(!x) sum=-sum;    return sum;}inline int ab(int x){return x<0?-x:x;}int num_boy,num_gril;int boy[N],girl[N];char ar[N];int main() {  while(~scanf("%d%d",&n,&m)&&(n+m)){    for(int i=0;i<=205;++i)      for(int j=0;j<=205;++j)        weight[i][j]=INF;    num_boy=num_gril=0;    for(int i=0;i<n;++i){      scanf("%s",ar);      for(int j=0;j<=m;++j){        if(ar[j]=='H'){          girl[num_gril++]=i*m+j;        }else if(ar[j]=='m'){          boy[num_boy++]=i*m+j;        }      }    }    n=num_boy;    for(int i=0;i<n;++i){      for(int j=0;j<n;++j){        int u=boy[i],v=girl[j];        weight[i][j]=min(ab(u/m-v/m)+ab(u%m-v%m), weight[i][j]);      }    }    printf("%d\n",fax(0));  }  return 0;}*/